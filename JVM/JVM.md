# JVM 知识点

## 1 垃圾回收机制
- 垃圾回收机制，主要针对：堆的内存进行回收。因为此两个区域的内存在JVM运行过程中会有积累，占用内存，不回收会越来越多。
- 程序计数器、虚拟机栈、本地方法栈这三个内存区域跟随线程生死，所以无需回收。

### 1.1 对象存活判断
#### 1.1.1 计数器：
- 每增加一个引用计数器+1，引用消失计数器-1
- 优点：效率高。
- 缺点：无法解决对象间的相互引用问题。

#### 1.1.2 可达性分析
通过GC ROOTS对象作作为起点，从这些起点向下去搜索，所走过的路径叫做引用链，当一个对象到GC ROOTS没有任何引用链连接时，则证明此对象不可达。
##### 1.1.2.1 GC ROOTS对象
- 虚拟机栈(栈桢中的本地变量表)中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中JNI的引用的对象

##### 1.1.2.2 最终判定对象是否被回收
在可达性分析算法中不可达的对象，也并非就判定为“死亡”了；判定一个对象最终是否死亡，至少经历两次标记过程：

- 不可达的对象会被第一次标记；
- 第一次标记的对象，判断是否重写了FINALIZE方法，如果重写了而且没有执行过，则执行FINALIZE方法。
- 在FINALIZE()中，若对象重新和引用链上的任一对象建立关联，则不会被第二次标记，它则不会被回收。

### 1.2 垃圾收集器
因为每次在进行FULL GC的时候会触发STW(STOP THE WORLD)，垃圾收集器的优化的主要目的是为了减少STW的次数和减少每次STW的持续时间。
#### 1.2.1 Serial
- JDK1.3开始使用
- 对于新生代的使用的是复制算法，
- 对于老年代使用的是标记压缩算法。
- 设置方式：-XX:+UseSerialGC
#### 1.2.2 ParNew
- Serial的多线程版本, JDK1.4开始使用
- 新生代和老年代的算法与Serial算法一致，
- 设置方式：-XX:+UseParNewGC
- 设置线程数--XX:ParallelGCThreads
#### 1.2.3 Parallel Scavenge
- JDK1.4开始使用
- 关注吞吐量（运行用户程序所占的比重），主要针对CPU密集型应用，可以高效利用CPU 
- -XX:+UseParallelGC
- -XX:MaxGCPauseMillis 最大GC暂停毫秒数 
- -XX:GCTimeRatio GC时间所占比重 
- 收集器将尽力保证GC时间不超过设定值，但是这是以牺牲吞吐量和新生代空间换取的：新生代越小收集时间越小，导致GC更频繁，吞吐量也就下降了。 
- -XX:+UseAdaptiveSizePolicy 开关参数，开启后不需要手动指定-Xmn、-XX:SurvivorRatio、
- -XX:PretenureSizeThreshold等参数，jvm会动态调整
#### 1.2.4 Parallel Old
- JDK1.6开始使用
- Parallel Scavenge收集器的老年代版本，多线程和“标记-整理”算法。
- 在注重吞吐量和CPU资源敏感场合，优先考虑 Parallel Scavenge和Parallel Old。
- 设置方式：-XX:+UseParallelOldGC
#### 1.2.5 Serial Old
- JDK1.4, 与Parallel Scavenge联合使用
- Serial收集器的老年代版本，单线程收集器，使用“标记-整理”算法，主要用于Client模式。
- 另外一个主要作用：作为CMS收集器的后备预案，当发生Concurrent Mode Failure时使用。
#### 1.2.6 CMS
JDK1.5开始使用，关注最短停顿时间为目标的收集器，注重服务响应速度，更好的用户体验。

- 使用“标记-清除”算法。
- 分为4个步骤初始标记、并发标记、重新标记、并发清除 
- 其中初始标记、重新标记仍需要“Stop The World”，耗时长的并发标记和并发清除是可以与用户线程一起工作。 

并发低停顿收集器缺点： 

- 对CPU资源非常敏感。默认启动线程数是（CPU数+3）/ 4。当CPU在4个以上时，并发回收最多占用不超过25%的CPU资源，但是当CPU不足4个时，差不多占用一半的CPU资源，如果此时负载较大时，对用户线程来说很有压力。 
- 存在失败风险，从而导致另外一次fullGC，并且会临时使用Serial Old收集器。因为CMS工作时，需要预留足够的内存空间给用户线程使用，默认在68%时激活GC。 
- 清除算法容易导致空间碎片。碎片过多会导致在老年代还有很多剩余空间时大对象无法分配，不得不提前触发FullGC。 
- -XX:+UseCMSCompactAtFullCollection 开启后，在FullGC后进行碎片整理，会增大停顿时间 
- -XX:CMSFullGCsBeforeCompaction 设置多少次FullGC后进行一次压缩处理。
- -XX:CMSInitiatingOccupancyFraction 触发GC的百分比，适当提高，可以降低回收次数，设的太高很容易导致“Concurrent Mode Failure”，性能反而下降 

## 2 内存模型
### 2.1 Java堆
- 被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。
- Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。
### 2.2 方法区
- 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。
- 从 JDK1.7 开始HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。
- 在 JDK1.8 中，永久代已完全被元空间(Meatspace)所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
- 方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。
- 运行时常量池是方法区的一部分。
- 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。
### 2.3 虚拟机栈
- 线程私有的，它的生命周期与线程相同。
- 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
- 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）
- 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
### 2.4 程序计数器
- 线程私有，它的生命周期与线程相同。
- 可以看做是当前线程所执行的字节码的行号指示器。
- 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（undefined）。
- 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OutOfMemoryError的情况。
### 2.5 本地方法栈
- 线程私有
- 与虚拟机栈非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

## 3. 类加载

### 3.1 类加载的过程
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）

#### 3.1.1 加载(Loading)
在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

#### 3.1.2 验证(Verification)
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
#### 3.1.3 准备(Preparation)

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
```java
public static int value=123;
```
那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。
至于“特殊情况”是指：
```java
public static final int value=123
```
即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0.

#### 3.1.4 解析(Resolution)
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

#### 3.1.5 初始化(Initialization)
类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<clinit>()方法的过程.
<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下：
```java
public class Test
{
    static
    {
        i=0;
        System.out.println(i);//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）
    }
    static int i=1;
}
```
那么去掉报错的那句，改成下面：
```java
public class Test
{
	static
	{
		i=0;
//		System.out.println(i);
	}
	static int i=1;
	
	public static void main(String args[])
	{
		System.out.println(i);
	}
}
```

输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行static块中的i=0,接着执行static赋值操作i=1,最后在main方法中获取i的值为1。

<clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<cinit>()方法执行之前，父类的<clinit>()方法已经执行完毕，回到本文开篇的举例代码中，结果会打印输出：SSClass就是这个道理。

由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
<clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。

```java
package jvm.classload;

public class DealLoopTest
{
    static class DeadLoopClass
    {
        static
        {
            if(true)
            {
                System.out.println(Thread.currentThread()+"init DeadLoopClass");
                while(true)
                {
                }
            }
        }
    }

    public static void main(String[] args)
    {
        Runnable script = new Runnable(){
            public void run()
            {
                System.out.println(Thread.currentThread()+" start");
                DeadLoopClass dlc = new DeadLoopClass();
                System.out.println(Thread.currentThread()+" run over");
            }
        };

        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start();
        thread2.start();
    }
}
```
运行结果：（即一条线程在死循环以模拟长时间操作，另一条线程在阻塞等待）
```java
Thread[Thread-0,5,main] start
Thread[Thread-1,5,main] start
Thread[Thread-0,5,main]init DeadLoopClass
```